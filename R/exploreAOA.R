#' Explore Area of Applicability
#'
#' @description
#' This function lets the user explore an calculated Area of Applicability object
#' interactively in an R shiny application. Depending on whether the parameter \code{LPD = TRUE}
#' was specified in the calculation of the \code{AOA}, the user can either explore the
#' \code{AOA} and \code{DI} layer or additionally explore the \code{LPD} and a reactive \code{neighbor-dependent
#' AOA layer}.
#' The functionality is very suitable for a first visual interpretation of the
#' Area of Applicability.
#'
#' @param aoa An R object of class \code{aoa} (generated by the \code{\link{aoa}} function).
#'
#' @details
#' Interpretation of results: If a location is very similar to the properties
#' of the training data it will have a low distance in the predictor variable space
#' (\code{DI} towards 0) while locations that are very different in their properties
#' will have a high \code{DI}.
#' Depending on a threshold for the DI, the location will either be classified as
#' \code{Inside AOA (1)} or \code{Outside AOA (0)}. The comparison is done for the nearest neighbor
#' of the training points in the predictor space. This can be seen in the \code{AOA} layer.
#' The \code{LPD} (Local Data Point Density) layer indicates the total number of training data points
#' for which the locations \code{DI} is smaller than the threshold, i.e. on how many similar training points the model was trained.
#' The fourth layer is based on the \code{LPD} layer and can be seen as a \code{neighbor-dependet AOA}. This layer extends the \code{AOA}
#' by a minimum number k of training data points for which the threshold condition must hold in order to be classified as \code{Indside AOA (1)}.
#'
#'
#'
#' @author
#' Fabian Schumacher
#' @references Meyer, H., Pebesma, E. (2021): Predicting into unknown space?
#' Estimating the area of applicability of spatial prediction models.
#' Methods in Ecology and Evolution 12: 1620-1633. \doi{10.1111/2041-210X.13650}

#' @examples
#' \dontrun{
#'
#' }
#' @export exploreAOA
#' @aliases exploreAOA


###################
# Define Function # ------------------------------------------------------------
###################

exploreAOA <- function(aoa) {
  ########################
  # Check function input # -----------------------------------------------------
  ########################

  # check for class 'aoa'_______________________________________________________
  if (!inherits(aoa, "aoa")) {
    stop("Your passed data is not of class 'aoa'")
  }


  #############
  # Load data # ----------------------------------------------------------------
  #############

  # define raster layers and layer names _______________________________________
  message("Loading data...")
  LPD_available <- "LPD" %in% names(aoa)
  parameters <- aoa$parameters
  rasterImages <- c()
  rasterImages$AOA <- project(aoa$AOA, "epsg:4326")
  rasterImages$DI <- project(aoa$DI, "epsg:4326")
  if (LPD_available) {
    rasterImages$LPD <- project(aoa$LPD, "epsg:4326")
    rasterImages$AOA_LPD <- project(aoa$AOA, "epsg:4326") # initialize with AOA
    layerNames <-
      c(
        "AOA" = "AOA",
        "DI" = "DI",
        "LPD" = "LPD",
        "AOA (LPD-dependent)" = "AOA_LPD"
      )
  } else {
    layerNames <- c("AOA", "DI")
  }


  # calculate data plots _______________________________________________________
  message("Generating plots...")
  plots1 <- c()

  plots1$AOA$plot <- generatePlot1(rasterImages$AOA, "AOA")
  plots1$AOA$title <- "AOA histogram"
  plots1$AOA$description <- "The AOA histogram shows the distribution of the AOA values. The AOA values are either 0 (outside AOA) or 1 (inside AOA)."

  plots1$DI$plot <- generatePlot1(rasterImages$DI, "DI")
  plots1$DI$title <- "DI density plot"
  plots1$DI$description <- "The DI density plot shows the distribution of the DI values."

  if (LPD_available) {
    plots1$LPD$plot <- generatePlot1(rasterImages$LPD, "LPD")
    plots1$LPD$title <- "LPD histogram"
    plots1$LPD$description <- "The LPD histogram shows the distribution of the LPD values. The LPD values are the number of training data points for which the DI is smaller than the threshold."

    plots1$AOA_LPD$plot <- generatePlot1(rasterImages$LPD, "AOA_LPD", 1) #init with k = 1
    plots1$AOA_LPD$title <- "LPD histogram (AOA colored)"
    plots1$AOA_LPD$description <- "The LPD (AOA colored) histogram shows the distribution of the LPD values."
  }


  plots2 <- c()

  plots2$AOA$plot <- generatePlot2(parameters$trainDI, "AOA", thres = parameters$threshold)
  plots2$AOA$title <- "trainDI boxplot"
  plots2$AOA$description <- "The trainDI boxplot shows the distribution of the trainDI values."

  plots2$DI$plot <- ggplotly(plot(aoa)[[1]]) %>% layout(legend = list(bgcolor = "rgba(0,0,0,0)", x = 0.95, xanchor = "right", y = 1, yanchor = "top")) %>% config(displayModeBar = FALSE)
  plots2$DI$title <- "trainDI, predictionDI density plot"
  plots2$DI$description <- "The trainDI, predictionDI density plot shows the distribution of the trainDI and predictionDI values."

  if (LPD_available) {
    plots2$LPD$plot <- generatePlot2(rasterImages, "LPD", thres = parameters$threshold)
    plots2$LPD$title <- "LPD~DI plot (binned)"
    plots2$LPD$description <- "The LPD~DI plot (binned) shows the distribution of the LPD values for each DI value."

    plots2$AOA_LPD$plot <- generatePlot2(rasterImages$LPD, "AOA_LPD", 1) #init with k = 1
    plots2$AOA_LPD$title <- "AOA (LPD-dependent) histogram"
    plots2$AOA_LPD$description <- "The AOA (LPD-dependent) histogram shows the distribution of the AOA (LPD-dependent) values. The AOA (LPD-dependent) values are either 0 (outside AOA) or 1 (inside AOA)."
  }


  # define legend props for the AOA, DI and LPD ________________________________
  legendProperties <- list(
    AOA = list(
      pal = NULL,
      colors = c("#fdb138", "#025196"),
      labels = c("Outside (0)", "Inside (1)"),
      values = as.numeric(values(rasterImages$AOA)),
      title = "AOA"
    ),
    DI = list(
      pal = colorNumeric(palette = "viridis",
                         domain = as.numeric(values(rasterImages$DI))),
      colors = viridis(30),
      labels = NULL,
      values = as.numeric(values(rasterImages$DI)),
      title = "DI"
    )
  )
  if (LPD_available) {
    legendProperties <- list.append(
      legendProperties,
      LPD = list(
        pal = colorNumeric(palette = "viridis",
                           domain = as.numeric(values(
                             rasterImages$LPD
                           ))),
        colors = viridis(30),
        labels = NULL,
        values = as.numeric(values(rasterImages$LPD)),
        title = "LPD"
      )
    )
    legendProperties <- list.append(
      legendProperties,
      AOA_LPD = list(
        pal = NULL,
        colors = c("#fdb138", "#025196"),
        labels = c("Outside (0)", "Inside (1)"),
        values = as.numeric(values(rasterImages$AOA)),
        title = "AOA (LPD-dependent)"
      )
    )
  }


  # define model props and build data.frame from model props____________________
  message("Extracting model properties...")
  if (LPD_available) {
    if (!is.null(parameters$avrgLPD)) {
      avrgLPD <- parameters$avrgLPD
    } else {
      avrgLPD <- NA
    }
    maxLPD <- parameters$maxLPD
    if (parameters$maxLPD < max(values(rasterImages$LPD, na.rm = T))) {
      maxLPD <- parameters$maxLPD
    } else {
      maxLPD <- max(values(rasterImages$LPD, na.rm = T))
    }
  }
  parameters <-
    c(c(parameters$threshold),
      c(parameters$scaleparam$dim[1]),
      c(parameters$method))

  rownames <- c()
  if (LPD_available) {
    parameters <- append(parameters, c(maxLPD), 2)
    parameters <- append(parameters, c(avrgLPD), 3)
    rownames <-
      c("DI threshold",
        "Sample size",
        "Max. LPD",
        "Avrg trainLPD",
        "Distance method")
  } else {
    rownames <- c("DI threshold", "Sample size", "Distance method")
  }

  parameters_df <- data.frame(parameters)
  row.names(parameters_df) <- rownames

  parameters_df["DI threshold",] <-
    round(as.numeric(parameters_df["DI threshold",]), digits = 3)
  parameters_df["Sample size",] <-
    as.integer(parameters_df["Sample size",])
  if (parameters_df["Distance method",] == "L2") {
    parameters_df["Distance method",] <- "Euclidian Distance"
  } else if (parameters_df["Distance method",] == "MD") {
    parameters_df["Distance method",] <- "Mahalanobis Distance"
  }
  if (LPD_available) {
    parameters_df["Max. LPD",] <-
      as.integer(parameters_df["Max. LPD",])
    parameters_df["Avrg trainLPD",] <-
      as.integer(parameters_df["Avrg trainLPD",])
  }


  # define layer extend ________________________________________________________
  extent <- ext(rasterImages$AOA)
  xmin <- as.numeric(extent[1])
  xmax <- as.numeric(extent[2])
  ymin <- as.numeric(extent[3])
  ymax <- as.numeric(extent[4])


  # define marker icon _________________________________________________________
  xmark <-
    makeIcon(
      system.file("images", "xmark.png", package = "CAST"),
      iconWidth = 18,
      iconHeight = 18
    )

  light <- bs_theme(bootswatch = "yeti")
  dark <- bs_theme(bootswatch = "yeti", bg = "#333", fg = "#fff")

  link_github <- tags$a(shiny::icon("github"), "CAST - exploreAOA", href = "https://github.com/fab-scm/CAST/blob/master/R/exploreAOA.R", target = "_blank")



  #############
  # Define UI # ----------------------------------------------------------------
  #############

  message("Building UI...")
  ui <- page_navbar(
    tags$style(
      ".nomargin .form-group { margin-bottom: 0px; } #pixelValues .table { margin-bottom: 0px; }"
    ),
    title = "Explore AOA",
    theme = light,
    padding = "0",
    nav_panel(
      title = "Map",
      icon = icon("map"),
      layout_sidebar(
        sidebar = sidebar(
          position = "left",
          width = 400,
          open = "always",
          selectInput("layerSelect", "Layer",
                      layerNames),
          sliderInput(
            "opacity",
            "Opacity",
            min(0),
            max(1),
            value = 1,
            step = 0.01
          ),
          downloadButton("downloadTiff", "Download GeoTiff"),
          if (LPD_available) {
            conditionalPanel(
              condition = "input.layerSelect == 'AOA_LPD'",
              tags$hr(style = "border: 1px solid #ccc; width: 100%;"),
              sliderInput(
                "k",
                "Min. LPD",
                min(1),
                max(maxLPD),
                value = 1,
                step = 1
              )
            )
          },
          tags$hr(style = "border: 1px solid #ccc; width: 100%;"),
          fileInput(
            "trainLocations",
            label = "Upload your training locations",
            multiple = FALSE,
            accept = c(".geojson", ".gpkg")
          ),
          conditionalPanel(
            condition = "output.uploadHappened == 'yes'",
            tags$div(class = "nomargin", checkboxInput("showTrainDat", "Show training locations"))
          ),
          tags$hr(style = "border: 1px solid #ccc; width: 100%;"),
          tags$h5(style = "font-weight: bold;", "Model Props:"),
          tableOutput("modelProps"),
        ),
        class = "p-0 gap-0",
        layout_sidebar(
          sidebar = sidebar(
            position = "right",
            width = 500,
            card(
              height = 380,
              full_screen = TRUE,
              card_header(textOutput("plot1title"), tooltip(bsicons::bs_icon("question-circle"), textOutput("plot1description"), placement = "right"), class = "d-flex align-items-center gap-1"),
              card_body(plotlyOutput("plot1"), proxy.height = 380)
            ),
            card(
              height = 380,
              full_screen = TRUE,
              card_header(textOutput("plot2title"), tooltip(bsicons::bs_icon("question-circle"), textOutput("plot2description"), placement = "right"), class = "d-flex align-items-center gap-1"),
              card_body(plotlyOutput("plot2"), proxy.height = 380)
            )
          ),
          class = "p-0 gap-0",
          leafletOutput(outputId = "map",
                        height = "100vh"),
          conditionalPanel(condition = "output.showPanel == 'clicked'",
                           absolutePanel(
                             bottom = 40,
                             left = 10,
                             width = 170,
                             draggable = TRUE,
                             card(card_header("Pixel values"),card_body(tableOutput("pixelValues"), padding = "4px"))
                           ))
        )
      )
    ),
    nav_spacer(),
    nav_item(tags$div(class = "nomargin", switchInput(inputId = "dark_mode", value = FALSE, label = icon("moon"), width = "auto", size = "small", inline = TRUE))),
    nav_menu(
      title = "Links",
      nav_item(link_github),
      align = "right"
    )
  )


  #################
  # Define server # ------------------------------------------------------------
  #################

  message("Building server...")
  server <- function(input, output, session) {

    # define reactive values ___________________________________________________
    rv <- reactiveValues(
      map = NULL,
      clickOccurred = "not clicked",
      AOA_LPD = rasterImages$AOA_LPD,
      plot1 = NULL,
      plot2 = NULL,
      uploadHappened = "no"
    )


    # theme handling ___________________________________________________________
    observe(session$setCurrentTheme(
      if (isTRUE(input$dark_mode)) dark else light
    ))

    # define leaflet map outout ________________________________________________
    output$map <- renderLeaflet({
      rv$map <-
        leaflet(options = leafletOptions(minZoom = 2, maxZoom = 19)) %>%
        addTiles(group = "OSM") %>%
        addProviderTiles(providers$Esri, group = "Esri") %>%
        addProviderTiles(providers$Esri.WorldGrayCanvas, group = "Esri World Gray Canvas") %>%
        addProviderTiles(providers$Esri.WorldImagery, group = "Esri World Imagery") %>%
        setMaxBounds(
          lng1 = xmin - 180,
          # Minimum longitude
          lat1 = ymin - 90,
          # Minimum latitude
          lng2 = xmax + 180,
          # Maximum longitude
          lat2 = ymax + 90     # Maximum latitude
        ) %>%
        fitBounds(
          lng1 = xmin,
          lat1 = ymin,
          lng2 = xmax,
          lat2 = ymax
        ) %>%
        addScaleBar(position = "bottomleft")
      rv$map
    })


    # raster layer image handling ______________________________________________
    observe({
      if (!is.null(rv$map) &&
          !is.null(rasterImages[[input$layerSelect]])) {
        showPageSpinner()
        layerLegendProps <- legendProperties[[input$layerSelect]]
        if (input$layerSelect == "AOA_LPD") {
          rasterImages$AOA_LPD[rasterImages$LPD < input$k] <- 0
          rasterImages$AOA_LPD[rasterImages$LPD >= input$k] <- 1
          rv$AOA_LPD <- rasterImages$AOA_LPD
          leafletProxy("map") %>%
            clearImages() %>%
            clearControls() %>%
            addRasterImage(rv$AOA_LPD,
                           colors = layerLegendProps$colors,
                           opacity = input$opacity,
                           group = "Raster") %>%
            addLegend(
              position = "bottomright",
              colors = layerLegendProps$colors,
              labels = layerLegendProps$labels,
              values = layerLegendProps$values,
              title = layerLegendProps$title,
              opacity = 1
            ) %>%
            addLayersControl(
              baseGroups = c("OSM", "Esri", "Esri World Gray Canvas", "Esri World Imagery"),
              overlayGroups = c("Raster"),
              options = layersControlOptions(position = "topleft")
            )
        }
        if (is.null(layerLegendProps$pal)) {
          leafletProxy("map") %>%
            clearImages() %>%
            clearControls() %>%
            addRasterImage(rasterImages[[input$layerSelect]],
                           colors = layerLegendProps$colors,
                           opacity = input$opacity,
                           group = "Raster") %>%
            addLegend(
              position = "bottomright",
              colors = layerLegendProps$colors,
              labels = layerLegendProps$labels,
              values = layerLegendProps$values,
              title = layerLegendProps$title,
              opacity = 1
            ) %>%
            addLayersControl(
              baseGroups = c("OSM", "Esri", "Esri World Gray Canvas", "Esri World Imagery"),
              overlayGroups = c("Raster"),
              options = layersControlOptions(position = "topleft")
            )
        } else {
          leafletProxy("map") %>%
            clearImages() %>%
            clearControls() %>%
            addRasterImage(rasterImages[[input$layerSelect]],
                           colors = layerLegendProps$colors,
                           opacity = input$opacity,
                           group = "Raster") %>%
            addLegend(
              position = "bottomright",
              pal = layerLegendProps$pal,
              values = layerLegendProps$values,
              title = layerLegendProps$title,
              opacity = 1
            ) %>%
            addLayersControl(
              baseGroups = c("OSM", "Esri", "Esri World Gray Canvas", "Esri World Imagery"),
              overlayGroups = c("Raster"),
              options = layersControlOptions(position = "topleft")
            )
        }
        hidePageSpinner()
      }
    })


    # plot handling on input$layerSelect or input$k change _____________________
    observe({
      message("Rendndering plots...")
      if (input$layerSelect == "AOA_LPD"){
        rv$plot1 <- generatePlot1(rasterImages$LPD, "AOA_LPD", input$k)
        rv$plot2 <- generatePlot2(rasterImages$LPD, "AOA_LPD", input$k)
      } else {
        rv$plot1 <- plots1[[input$layerSelect]]$plot
        rv$plot2 <- plots2[[input$layerSelect]]$plot
      }
    })

    output$plot1 <- renderPlotly({
      rv$plot1
    })

    output$plot2 <- renderPlotly({
      rv$plot2
    })

    output$plot1title <- renderText({
      plots1[[input$layerSelect]]$title
    })

    output$plot2title <- renderText({
      plots2[[input$layerSelect]]$title
    })

    output$plot1description <- renderText({
      plots1[[input$layerSelect]]$description
    })

    output$plot2description <- renderText({
      plots2[[input$layerSelect]]$description
    })


    # handling of training location upload _____________________________________
    observeEvent(input$trainLocations, {
      rv$uploadHappened <- "yes"
      updateCheckboxInput(session, "showTrainDat", value = TRUE)
    })

    output$uploadHappened <- reactive({
      rv$uploadHappened
    })
    outputOptions(output, "uploadHappened", suspendWhenHidden = FALSE)

    observeEvent(input$showTrainDat, {
      if (input$showTrainDat == TRUE && rv$uploadHappened == "yes") {
        # Read the uploaded GeoJSON/GeoPackage file
        trainLocations <- st_read(input$trainLocations$datapath)
        trainLocations <- as_Spatial(trainLocations)

        # Add the GeoJSON data to the Leaflet map
        leafletProxy("map") %>%
          addCircleMarkers(
            data = trainLocations,
            group = "trainLocations",
            color = "#ff3535",
            stroke = TRUE,
            fillColor = "white",
            radius = 3,
            fillOpacity = 10
          )
      } else if (input$showTrainDat == FALSE &&
                 rv$uploadHappened == "yes") {
        leafletProxy("map") %>%
          clearGroup(group = "trainLocations")
      }
    })


    # render model props table _________________________________________________
    output$modelProps <- renderTable({
      return(parameters_df)
    },
    width = "100%",
    align = "lr",
    rownames = TRUE,
    colnames = FALSE,
    striped = TRUE)


    # map click handling _______________________________________________________
    observeEvent(input$map_click, {
      rv$clickOccurred <- "clicked"
      click <- input$map_click
      lng <- click$lng
      lat <- click$lat

      leafletProxy("map") %>%
        removeMarker(layerId = c("xmark")) %>%
        addMarkers(
          layerId = "xmark",
          lng = lng,
          lat = lat,
          icon = xmark
        )
    })

    output$showPanel <- reactive({
      rv$clickOccurred
    })
    outputOptions(output, "showPanel", suspendWhenHidden = FALSE)

    output$pixelValues <- renderTable({
      click <- input$map_click
      if (is.null(click)) {
        return()
      }

      # get coordinates from click event
      lng <- click$lng
      lat <- click$lat

      # extract raster values
      AOA_value <- as.numeric(terra::extract(rasterImages$AOA,
                                      cbind(lng, lat)))
      DI_value <- as.numeric(round(terra::extract(rasterImages$DI,
                                     cbind(lng, lat)),2))
      if (LPD_available) {
        LPD_value <- as.numeric(terra::extract(rasterImages$LPD,
                                        cbind(lng, lat)))
        AOA_LPD_value <- as.numeric(terra::extract(rv$AOA_LPD,
                                            cbind(lng, lat)))
      }

      values_df <- c(c(AOA_value), c(DI_value))
      if (LPD_available) {
        values_df <- c(values_df, c(LPD_value), c(AOA_LPD_value))
        rownames <- c("AOA", "DI", "LPD", "AOA_LPD")
      } else {
        rownames <- c("AOA", "DI")
      }

      # convert to df
      values_df <- data.frame(values_df)
      rownames(values_df) <- rownames

      # format AOA values for table output
      if (is.na(values_df["AOA",])) {
        values_df["AOA",] <- values_df["AOA",]
      } else if (as.integer(values_df["AOA",]) == 0) {
        values_df["AOA",] <- "Outside"
      } else if (as.integer(values_df["AOA",]) == 1) {
        values_df["AOA",] <- "Inside"
      }

      if (LPD_available) {
        # format AOA_LPD values for table output
        if (is.na(values_df["AOA_LPD",])) {
          values_df["AOA_LPD",] <- values_df["AOA_LPD",]
        } else if (as.integer(values_df["AOA_LPD",]) == 0) {
          values_df["AOA_LPD",] <- "Outside"
        } else if (as.integer(values_df["AOA_LPD",]) == 1) {
          values_df["AOA_LPD",] <- "Inside"
        }
        values_df["LPD",] <- as.integer(values_df["LPD",])
      }

      if (!is.na(values_df["AOA",])) {
        return(values_df)
      } else {
        return("NA")
      }
    },
    width = "100%",
    align = "lr",
    rownames = TRUE,
    colnames = FALSE,
    striped = TRUE,
    hover = TRUE)

    # download handler _________________________________________________________
    output$downloadTiff <- downloadHandler(
      filename = function() {
        paste0(input$layerSelect, ".tif")
      },
      content = function(file) {
        # Generate and save your TIFF data to the file
        if (input$layerSelect == "AOA_LPD") {
          layer <- rv$AOA_LPD
        } else {
          layer <- rasterImages[[input$layerSelect]]
        }
        # layer <- rasterImages[[input$layerSelect]]
        writeRaster(layer, filename = file)
      }
    )

  }



  ###############################
  # Create the Shiny app object # ----------------------------------------------
  ###############################

  message("Starting Shiny app...")
  shinyApp(ui = ui, server = server, options = list(launch.browser = TRUE))
}





generatePlot1 <- function(raster, layer, k = NULL) {
  if (layer == "AOA") {
    dfAOA = data.frame(AOA = as.integer(terra::values(raster, na.rm = T)))
    plot = ggplot(dfAOA, aes(x = factor(AOA), fill = factor(after_stat(x)))) +
      geom_bar(show.legend = FALSE) +
      geom_text(
        aes(label=paste(after_stat(round(prop*100, 2)), " %"), group=1),
        stat='count',
        nudge_y=8000,
        show.legend = FALSE
      ) +
      scale_fill_manual(values = c("#fdb138", "#025196"))
    plot = plot + xlab("AOA")
    plot = hide_legend(ggplotly(plot, tooltip = c("count", "AOA")) %>% config(displayModeBar = FALSE))
  } else if (layer == "DI") {
    dfDI = data.frame(DI = as.numeric(terra::values(raster, na.rm = T)))
    density <- density(dfDI$DI, n = 1024, adjust = 1.5)
    plot = ggplot(data.frame(DI = density$x, density = density$y), aes(DI, density)) + geom_line() +
      geom_segment(aes(xend = DI, yend = 0, colour = DI), show.legend = FALSE) +
      scale_color_viridis()
    plot = ggplotly(plot, tooltip = c("x", "y")) %>% config(displayModeBar = FALSE)
  } else if (layer == "LPD") {
    dfLPD = data.frame(LPD = as.integer(terra::values(raster , na.rm = T)))
    plot = ggplot(dfLPD, aes(x = LPD, fill = after_stat(x))) + geom_bar(show.legend = FALSE) + scale_fill_viridis()
    plot = ggplotly(plot, tooltip = c("count", "LPD")) %>% config(displayModeBar = FALSE)
  } else if (layer == "AOA_LPD") {
    dfAOA_LPD = data.frame(LPD = as.integer(terra::values(raster , na.rm = T)))
    dfAOA_LPD <- dfAOA_LPD %>% mutate(AOA = ifelse(LPD < k, 0, 1))
    plot = ggplot(dfAOA_LPD, aes(x = LPD, fill = factor(AOA))) + geom_bar(show.legend = FALSE) + scale_fill_manual(values = c("#fdb138", "#025196"))
    plot = hide_legend(ggplotly(plot, tooltip = c("count", "LPD")) %>% config(displayModeBar = FALSE))
  }
  return(plot)
}


generatePlot2 <- function(raster, layer, k = NULL, thres = NULL) {
  if (layer == "AOA") {
    dfTrainDI = data.frame(trainDI = as.numeric(raster, na.rm = T))
    plot = ggplot(dfTrainDI, aes(x = "", y = trainDI)) + geom_boxplot(show.legend = FALSE, fill = "#69b3a2") + geom_hline(aes(yintercept = thres, linetype = "AOA_threshold")) + scale_linetype_manual(name = "", values = c(AOA_threshold = "dashed"))
    plot = ggplotly(plot) %>% layout(legend = list(bgcolor = "rgba(0,0,0,0)", x = 0.95, xanchor = "right", y = 1, yanchor = "top")) %>% config(displayModeBar = FALSE)
  } else if (layer == "DI") {
    plot = NULL
  } else if (layer == "LPD") {
    df = data.frame(DI = as.numeric(terra::values(raster$DI, na.rm = T)), LPD = as.integer(terra::values(raster$LPD, na.rm = T)))
    plot = ggplot(df, aes(x = LPD, y = DI)) + geom_bin_2d(breaks=list(x = seq(-0.5,max(df$LPD)+1,1), y = seq(0, ceiling(max(df$DI)), 0.01))) + scale_fill_viridis(option ="H") + geom_hline(aes(yintercept = thres, linetype = "AOA_threshold")) + scale_linetype_manual(name = "", values = c(AOA_threshold = "dashed"))
    plot = ggplotly(plot) %>% layout(legend = list(bgcolor = "rgba(0,0,0,0)", x = 0.95, xanchor = "right", y = 1, yanchor = "top")) %>% config(displayModeBar = FALSE)
  } else if (layer == "AOA_LPD") {
    dfAOA_LPD = data.frame(LPD = as.integer(terra::values(raster , na.rm = T)))
    dfAOA_LPD <- dfAOA_LPD %>% mutate(AOA = ifelse(LPD < k, 0, 1))
    plot = ggplot(dfAOA_LPD, aes(x = factor(AOA), fill = factor(after_stat(x)))) +
      geom_bar(show.legend = FALSE) +
      geom_text(
        aes(label=paste(after_stat(round(prop*100, 2)), " %"), group=1),
        stat='count',
        nudge_y=8000,
        show.legend = FALSE
      ) +
      scale_fill_manual(values = c("#fdb138", "#025196"))
    plot = plot + xlab("AOA")
    plot = hide_legend(ggplotly(plot, tooltip = c("count", "AOA")) %>% config(displayModeBar = FALSE))
  }
  return(plot)
}
